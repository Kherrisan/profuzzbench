diff --git a/generator/pass/fuzztruction-source-clang-fast.c b/generator/pass/fuzztruction-source-clang-fast.c
index 47294d0..45bd76d 100644
--- a/generator/pass/fuzztruction-source-clang-fast.c
+++ b/generator/pass/fuzztruction-source-clang-fast.c
@@ -36,12 +36,20 @@ typedef struct {
 
 const char* PASS_SO_NAME = "fuzztruction-source-llvm-pass.so";
 char *pass_path;
+char generator_agent_linkage[1024];
 
 void find_pass()
 {
     char *guess;
     char *cwd;
 
+    char *pass_path_env = getenv("LLVM_PASS_SO");
+    if (pass_path_env != NULL && !access(pass_path_env, R_OK))
+    {
+        pass_path = pass_path_env;
+        goto done;
+    }
+
     cwd = getcwd(NULL, 0);
     if (!cwd) {
         PFATAL("Failed to get CWD");
@@ -163,7 +171,16 @@ args_t* rewrite_argv(const char *argv[], int argc, arg_settings_t* arg_settings)
     }
 
     // Link against our agent that is called by a call our pass injected into main().
-    self->argv[self->argc++] = "-L/home/user/fuzztruction/target/debug";
+    char *generator_agent_dir = getenv("GENERATOR_AGENT_SO_DIR");
+    if (generator_agent_dir != NULL)
+    {
+        sprintf(generator_agent_linkage, "-L%s", generator_agent_dir);
+        self->argv[self->argc++] = generator_agent_linkage;
+    }
+    else
+    {
+        self->argv[self->argc++] = "-L/home/user/fuzztruction/target/debug";
+    }
     self->argv[self->argc++] = "-lgenerator_agent";
     self->argv[self->argc++] = "-DNDEBUG";
 
diff --git a/lib/jail/src/jail.rs b/lib/jail/src/jail.rs
index 3aa7cd0..36c6797 100644
--- a/lib/jail/src/jail.rs
+++ b/lib/jail/src/jail.rs
@@ -118,12 +118,12 @@ impl Jail {
         // Mount the bear minimum to allow execution of software.
 
         // Mount / into our new root
-        Jail::mount(&["--bind", "-o", "-ro", "/", &self.new_root])
+        Jail::mount(&["--bind", "-o", "ro", "/", &self.new_root])
             .context("Failed to mount / into new root")?;
         Jail::remount_bind_mount_ro(&self.new_root).context("Failed to remount / as ro")?;
 
         let default_ro_source_dirs = [
-            "/home/user/fuzztruction",
+            "/home/user/fuzztruction-net",
             "/etc/hosts",
             "/etc/hostname",
             "/etc/resolv.conf",
@@ -134,8 +134,8 @@ impl Jail {
             Jail::remount_bind_mount_ro(&dst).context("Failed to remount as ro")?;
         }
 
-        let dst = format!("{}{}", &self.new_root, "/home/user/fuzztruction/eval-result");
-        Jail::mount(&["--bind",  "/home/user/fuzztruction/eval-result", &dst]).context("Failed to mount eval-result RW")?;
+        let dst = format!("{}{}", &self.new_root, "/home/user/fuzztruction-net/eval-result");
+        Jail::mount(&["--bind",  "/home/user/fuzztruction-net/eval-result", &dst]).context("Failed to mount eval-result RW")?;
 
         // Mount /proc, /sys and /dev. These are shared since they are also marked as shared in the "parent" namespace.
         Jail::mount(&["-o", "bind", "/proc", &format!("{}/proc", self.new_root)])
diff --git a/scheduler/src/checks.rs b/scheduler/src/checks.rs
index 2689dde..68c2bd8 100644
--- a/scheduler/src/checks.rs
+++ b/scheduler/src/checks.rs
@@ -132,12 +132,12 @@ fn check_mqueue_queues_max() -> Result<()> {
 pub fn check_system() -> Result<()> {
     check_core_pattern_is_core()?;
     check_fs_suid_dumpable()?;
-    check_if_tmp_is_tmpfs()?;
+    // check_if_tmp_is_tmpfs()?;
     check_if_agent_is_in_path()?;
-    check_scaling_governor()?;
-    check_perf_event_paranoid()?;
-    check_file_limit()?;
-    check_mqueue_queues_max()?;
+    // check_scaling_governor()?;
+    // check_perf_event_paranoid()?;
+    // check_file_limit()?;
+    // check_mqueue_queues_max()?;
     Ok(())
 }
 
diff --git a/scheduler/src/cli/fuzztruction.rs b/scheduler/src/cli/fuzztruction.rs
index eb8c21d..a6457b1 100644
--- a/scheduler/src/cli/fuzztruction.rs
+++ b/scheduler/src/cli/fuzztruction.rs
@@ -358,6 +358,23 @@ fn parse_args() -> ArgMatches {
             Command::new("dump-stackmap")
                 .about("Dump the LLVM stackmap (e.g., locations and sizes)")
         )
+        .subcommand(
+            Command::new("gcov")
+                .about("Run gcov for each insteresting input found.")
+                .arg(
+                    Arg::new("timeout")
+                        .help("Timeout after that a testcase is considered hanging and skipped in consequence")
+                        .short('t')
+                        .long("timeout")
+                        .takes_value(true)
+                        .default_value("1s"),
+                ).arg(
+                    Arg::new("overwrite")
+                    .long("overwrite")
+                    .help("Rerun the coverage computation and delete previous results, if any")
+                    .action(clap::ArgAction::SetTrue)
+                )
+        )
         .subcommand(
             Command::new("test-patchpoints")
             .about("Test the patchpoints of the source application (for debugging)")
@@ -507,6 +524,10 @@ fn real_main() -> Result<()> {
             handler::handle_cli_llvm_cov_subcommand(llvm_cov_matches, &config)
                 .expect("Failed to run llvm-cov subcommand");
         }
+        Some(("gcov", matches)) => {
+            handler::handle_cli_gcov_subcommand(matches, &config)
+                .expect("Failed to run gcov subcommand");
+        }
         Some(("aflnet", matches)) => {
             handler::handle_cli_aflnet_subcommand(matches, &config)
                 .expect("Failed to run AFLNet mode");
diff --git a/scheduler/src/cli/handler.rs b/scheduler/src/cli/handler.rs
index e98c37a..823e7dc 100644
--- a/scheduler/src/cli/handler.rs
+++ b/scheduler/src/cli/handler.rs
@@ -1,4 +1,5 @@
 use std::{
+    process::{Command, Stdio},
     sync::{self, atomic::AtomicBool, Arc},
     time::{Duration, Instant},
 };
@@ -271,6 +272,38 @@ pub(crate) fn handle_cli_sgfuzz_subcommand(matches: &ArgMatches, config: &Config
     Ok(())
 }
 
+pub(crate) fn handle_cli_gcov_subcommand(
+    trace_matches: &ArgMatches,
+    config: &Config,
+) -> Result<()> {
+    let termination_flag = register_on_termination_flag();
+    let timeout = trace_matches
+        .value_of("timeout")
+        .map(|e| e.parse::<CliDuration>().unwrap())
+        .map(|v| v.0)
+        .unwrap();
+
+    if trace_matches.get_flag("overwrite") {
+        let src_dir = config.gcov.as_ref().unwrap().src_dir.to_owned();
+        Command::new("gcovr")
+            .args(["-r", src_dir.to_str().unwrap(), "-s", "-d"])
+            .stdout(Stdio::null())
+            .stderr(Stdio::null())
+            .status()
+            .unwrap();
+    }
+
+    log::info!("Timeout is set to {timeout:?}");
+
+    coverage::networked::compute_gcov(config, termination_flag.clone(), timeout)?;
+
+    if termination_flag.load(std::sync::atomic::Ordering::SeqCst) {
+        return Ok(());
+    }
+
+    Ok(())
+}
+
 pub(crate) fn handle_cli_llvm_cov_subcommand(
     trace_matches: &ArgMatches,
     config: &Config,
diff --git a/scheduler/src/config.rs b/scheduler/src/config.rs
index 036e283..cde3028 100644
--- a/scheduler/src/config.rs
+++ b/scheduler/src/config.rs
@@ -289,6 +289,13 @@ pub struct StateAflConfig {
     pub enable_state_aware_mode: bool,
 }
 
+#[derive(Debug, Clone, Serialize)]
+pub struct GcovConfig {
+    pub bin_path: PathBuf,
+    pub env: Vec<(String, String)>,
+    pub src_dir: PathBuf,
+}
+
 #[derive(Debug, Clone, Serialize)]
 pub struct VanillaConfig {
     /// Environment used during binary
@@ -444,6 +451,8 @@ pub struct Config {
     pub stateafl: Option<StateAflConfig>,
     /// Config for the SGFuzz fuzzer.
     pub sgfuzz: Option<SGFuzzConfig>,
+
+    pub gcov: Option<GcovConfig>
 }
 
 impl Config {
@@ -1028,6 +1037,7 @@ impl ConfigBuilder {
                 "sink-cov",
                 "source",
                 "afl-net",
+                "gcov",
                 "state-afl",
                 "sgfuzz",
                 "vanilla",
@@ -1290,6 +1300,21 @@ impl ConfigBuilder {
         })
     }
 
+    fn parse_gcov_section(&self, yaml: &Yaml) -> Result<GcovConfig> {
+        let bin_path = self.get_attribute(yaml, "bin-path")?;
+        let env: Option<Vec<(String, String)>> = self.get_attribute(yaml, "env")?;
+        let env = env.unwrap_or_default();
+        let src_dir = self.get_attribute(yaml, "src-dir")?;
+
+        ConfigBuilder::check_for_unparsed_keys(yaml, &["bin-path", "env", "src-dir"])?;
+
+        Ok(GcovConfig {
+            bin_path,
+            env,
+            src_dir,
+        })
+    }
+
     fn parse_state_afl_section(&self, yaml: &Yaml) -> Result<StateAflConfig> {
         let bin_path = self.get_attribute(yaml, "bin-path")?;
         let env: Option<Vec<(String, String)>> = self.get_attribute(yaml, "env")?;
@@ -1477,6 +1502,13 @@ impl ConfigBuilder {
             Some(self.parse_afl_net_section(aflnet_section)?)
         };
 
+        let gcov_section = &yaml["gcov"];
+        let gcov_config = if gcov_section.is_null() || gcov_section.is_badvalue() {
+            None
+        } else {
+            Some(self.parse_gcov_section(gcov_section)?)
+        };
+
         let stateafl_section = &yaml["state-afl"];
         let stateafl_section = if stateafl_section.is_badvalue() {
             None
@@ -1508,6 +1540,7 @@ impl ConfigBuilder {
             sgfuzz: sgfuzz_section,
             sink_cov: sink_cov_config,
             vanilla: vanilla_config,
+            gcov: gcov_config
         };
         config.validate()?;
         Ok(config)
diff --git a/scheduler/src/coverage/networked.rs b/scheduler/src/coverage/networked.rs
index 8886de7..9ec7328 100644
--- a/scheduler/src/coverage/networked.rs
+++ b/scheduler/src/coverage/networked.rs
@@ -1,11 +1,17 @@
 use std::{
     cell::RefCell,
-    fs,
-    process::Command,
+    env,
+    ffi::CString,
+    fs::{self, OpenOptions},
+    io::{BufRead, BufReader, Write},
+    os::fd::AsRawFd,
+    path::PathBuf,
+    process::{Command, Stdio},
     sync::{
         atomic::{self, AtomicBool},
         Arc,
     },
+    thread::{self, sleep},
     time::{Duration, Instant},
 };
 
@@ -18,9 +24,12 @@ use crate::{
     source::Source,
 };
 
+use anyhow::anyhow;
 use anyhow::Result;
 use fuzztruction_shared::mutation_cache::MutationCache;
 use itertools::Itertools;
+use libc::fork;
+use nix::unistd::execve;
 
 unsafe fn load_mutations(source: &mut Source, entry: &QueueEntry) -> Result<()> {
     let mutations = entry.mutations();
@@ -39,6 +48,246 @@ unsafe fn load_mutations(source: &mut Source, entry: &QueueEntry) -> Result<()>
     Ok(())
 }
 
+pub fn compute_gcov(
+    config: &Config,
+    exit_requested: Arc<AtomicBool>,
+    timeout: Duration,
+) -> Result<()> {
+    let gcov_config = config.gcov.as_ref().unwrap();
+
+    let home_dir = env::var_os("HOME")
+        .or_else(|| env::var_os("USERPROFILE"))
+        .map(PathBuf::from)
+        .unwrap();
+
+    let cargo_grcov = home_dir.join(".cargo").join("bin").join("grcov");
+    if !cargo_grcov.exists() {
+        return Err(anyhow!("grcov not found in $HOME/.cargo/bin folder"));
+    }
+
+    let grcov_args = [
+        "-t",
+        "lcov",
+        "--branch",
+        "--ignore-not-existing",
+        "-s",
+        gcov_config.src_dir.to_str().unwrap(),
+        gcov_config.src_dir.to_str().unwrap(),
+    ];
+
+    let mut cov_tmp_file = tempfile::NamedTempFile::new().unwrap();
+    log::debug!(
+        "Coverage temp file: {}",
+        cov_tmp_file.path().to_str().unwrap()
+    );
+    cov_tmp_file
+        .write_all("time,l_per,l_abs,b_per,b_abs\n".as_bytes())
+        .unwrap();
+
+    let queue_path = config.general.queue_path();
+    log::info!("Loading queue at {queue_path:?} from disk...");
+    let queue = Queue::load(&queue_path, None)?;
+    log::info!("Tracing {} queue entries", queue.len());
+
+    let mut source = Source::from_config(config, None, Some("gcov")).unwrap();
+    source.start().expect("Failed to start source");
+    let _pp = source.get_patchpoints()?;
+
+    for (idx, entry) in queue.iter().sorted_by_key(|q| q.id().0).enumerate() {
+        if exit_requested.load(atomic::Ordering::SeqCst) {
+            break;
+        }
+
+        log::info!("Processing queue entry {:?}", entry.id());
+        let ts = entry.creation_ts().unwrap();
+        unsafe {
+            load_mutations(&mut source, &entry)?;
+        }
+        source.sync_mutations()?;
+
+        let pid = unsafe { fork() };
+
+        if pid == 0 {
+            let dev_null_fd = unsafe {
+                let path = CString::new("/dev/null".as_bytes()).unwrap();
+                libc::open(path.as_ptr(), libc::O_RDONLY)
+            };
+            if dev_null_fd < 0 {
+                panic!("Failed to open /dev/null");
+            }
+
+            let mut sink_workdir = config.general.work_dir.to_owned();
+            sink_workdir.push("0-gcov");
+            sink_workdir.push("sink");
+            sink_workdir.push("workdir");
+
+            if !sink_workdir.exists() {
+                fs::create_dir_all(&sink_workdir).expect("Failed to create sink workdir");
+            }
+
+            if config.sink.log_stdout {
+                let mut path = sink_workdir.to_owned();
+                path.push("stdout");
+                let file = OpenOptions::new()
+                    .read(true)
+                    .write(true)
+                    .create(true)
+                    .truncate(true)
+                    .open(&path)
+                    .unwrap();
+                let fd = file.as_raw_fd();
+                unsafe {
+                    libc::dup2(fd, libc::STDOUT_FILENO);
+                    libc::close(fd);
+                }
+            } else {
+                unsafe {
+                    libc::dup2(dev_null_fd, libc::STDOUT_FILENO);
+                }
+            }
+
+            if config.sink.log_stderr {
+                let mut path = sink_workdir.to_owned();
+                path.push("stderr");
+                let file = OpenOptions::new()
+                    .read(true)
+                    .write(true)
+                    .create(true)
+                    .truncate(true)
+                    .open(&path)
+                    .unwrap();
+                let fd = file.as_raw_fd();
+                unsafe {
+                    libc::dup2(fd, libc::STDERR_FILENO);
+                    libc::close(fd);
+                }
+            } else {
+                unsafe {
+                    libc::dup2(dev_null_fd, libc::STDERR_FILENO);
+                }
+            }
+
+            // is child
+            let argv: Vec<CString> = config
+                .sink
+                .arguments
+                .iter()
+                .map(|arg| CString::new(arg.to_owned()).unwrap())
+                .collect();
+            let bin_path = gcov_config.bin_path.to_str().unwrap();
+            log::trace!("Executing command line: {} {:#?}", bin_path, argv);
+            let bin = CString::new(bin_path).unwrap();
+
+            let envs: Vec<CString> = config
+                .gcov
+                .as_ref()
+                .unwrap()
+                .env
+                .iter()
+                .map(|e| CString::new(format!("{}={}", e.0, e.1)).unwrap())
+                .collect();
+            log::trace!("Environments: {:#?}", envs);
+            if let Err(e) = execve(&bin, &argv, &envs) {
+                log::error!("Error in executing execve: {:#?}", e);
+                let error = std::io::Error::last_os_error();
+                log::error!("Last os error: {:#?}", error);
+                std::process::exit(1);
+            }
+            unreachable!("unreachable: execve returns");
+        } else if pid > 0 {
+            // is parent
+        } else {
+            // pid < 0
+            return Err(anyhow!("Fork failed!"));
+        }
+
+        log::debug!("Target pid: {pid}");
+
+        // is parent
+        wait_listening(
+            pid,
+            config.sink.server_port.as_ref().unwrap().parse().unwrap(),
+            true,
+            timeout,
+        )?;
+
+        source.spawn(timeout)?;
+        thread::sleep(timeout);
+        let _ = nix::sys::signal::kill(nix::unistd::Pid::from_raw(pid), nix::sys::signal::SIGTERM);
+        source.wait_for_child_termination(timeout, true)?;
+
+        let grcov_output = Command::new(cargo_grcov.to_owned())
+            .args(grcov_args)
+            .stdout(Stdio::piped())
+            .spawn()
+            .map_err(|e| {
+                anyhow!(
+                    "Error in spawning: grcov {:#?}, caused by: {:#?}",
+                    grcov_args,
+                    e
+                )
+            })?
+            .stdout
+            .expect("Grcov process returns empty");
+
+        let mut lines_found = 0;
+        let mut lines_hit = 0;
+        let mut branches_found = 0;
+        let mut branches_hit = 0;
+
+        let reader = BufReader::new(grcov_output);
+        for line in reader.lines() {
+            let line = line?;
+            let parts: Vec<&str> = line.split(':').collect();
+
+            match parts[0] {
+                "LF" => lines_found += parts[1].parse::<u64>().unwrap_or(0),
+                "LH" => lines_hit += parts[1].parse::<u64>().unwrap_or(0),
+                "BRF" => branches_found += parts[1].parse::<u64>().unwrap_or(0),
+                "BRH" => branches_hit += parts[1].parse::<u64>().unwrap_or(0),
+                _ => {} // Ignore other lines
+            }
+        }
+
+        // Compute line coverage ratio
+        let l_per = if lines_found > 0 {
+            (lines_hit as f64 / lines_found as f64) * 100.0
+        } else {
+            0.0
+        };
+
+        // Compute branch coverage ratio
+        let b_per = if branches_found > 0 {
+            (branches_hit as f64 / branches_found as f64) * 100.0
+        } else {
+            0.0
+        };
+
+        // Format the absolute values and percentages
+        let l_abs = lines_hit;
+        let b_abs = branches_hit;
+        let l_per = format!("{:.4}", l_per);
+        let b_per = format!("{:.4}", b_per);
+
+        cov_tmp_file
+            .write_all(format!("{ts},{l_abs},{l_per},{b_abs},{b_per}\n").as_bytes())
+            .unwrap();
+        cov_tmp_file.flush().unwrap();
+
+        log::info!("Coverage:\nLine:\t{l_abs}({l_per}%)\nBranch:\t{b_abs}({b_per}%)");
+        log::info!(
+            "Finished measuring coverage of the {idx}-th queue entry, progress: {:.2}%",
+            idx as f64 / queue.len() as f64 * 100f64
+        );
+    }
+
+    cov_tmp_file
+        .persist(config.general.work_dir.join("coverage.csv"))
+        .unwrap();
+
+    Ok(())
+}
+
 pub fn compute_llvm_cov(
     config: &Config,
     exit_requested: Arc<AtomicBool>,
@@ -183,3 +432,62 @@ pub fn compute_llvm_cov(
 
     Ok(())
 }
+
+pub fn wait_listening(pid: i32, port: u16, v4: bool, timeout: Duration) -> Result<()> {
+    let start = Instant::now();
+    loop {
+        if is_listening(pid, port, v4)? {
+            return Ok(());
+        }
+        log::trace!("Waiting for the process to listen on the port");
+        if start.elapsed() > timeout {
+            return Err(anyhow!(
+                "Timeout in waiting for the process to listen on the port"
+            ));
+        }
+        sleep(Duration::from_millis(1));
+    }
+}
+
+fn is_listening(pid: i32, port: u16, v4: bool) -> Result<bool> {
+    let fd_path = format!("/proc/{}/fd", pid);
+    for entry in fs::read_dir(fd_path)? {
+        let entry = entry?;
+        let path = entry.path();
+        if let Ok(target) = fs::read_link(&path) {
+            if target.to_string_lossy().starts_with("socket:[") {
+                let inode = target
+                    .to_string_lossy()
+                    .trim_start_matches("socket:[")
+                    .trim_end_matches(']')
+                    .parse::<u64>()?;
+                if grep_socket_port(inode, port, v4)? {
+                    return Ok(true);
+                }
+            }
+        }
+    }
+    Ok(false)
+}
+
+fn grep_socket_port(inode: u64, port: u16, v4: bool) -> Result<bool> {
+    let tcp_socket_path = if v4 {
+        "/proc/net/tcp"
+    } else {
+        "/proc/net/tcp6"
+    };
+    let tcp_socket_file = fs::File::open(tcp_socket_path)?;
+    for line in BufReader::new(tcp_socket_file).lines().skip(1) {
+        let line = line?;
+        let parts: Vec<&str> = line.split_whitespace().collect();
+        if parts.len() > 9 {
+            let local_address = parts[1];
+            let local_port = u16::from_str_radix(&local_address[9..], 16)?;
+            let socket_inode = parts[9].parse::<u64>()?;
+            if local_port == port && socket_inode == inode {
+                return Ok(true);
+            }
+        }
+    }
+    Ok(false)
+}
diff --git a/scheduler/src/fuzzer/worker_impl/init.rs b/scheduler/src/fuzzer/worker_impl/init.rs
index 728d127..a2d288b 100644
--- a/scheduler/src/fuzzer/worker_impl/init.rs
+++ b/scheduler/src/fuzzer/worker_impl/init.rs
@@ -37,15 +37,6 @@ impl FuzzingWorker {
         self.source = Some(Source::from_config(&self.config, Some(self.uid.0), None)?);
         self.sink = Some(AflSink::from_config(&self.config, Some(self.uid.0), None)?);
 
-        let ret = unsafe { libc::unshare(libc::CLONE_NEWNET) };
-        assert!(ret == 0);
-
-        let ret = process::Command::new("ip")
-            .args(["link", "set", "dev", "lo", "up"])
-            .spawn()?
-            .wait_with_output()?;
-        log::info!("ret={:?}", ret);
-
         self.source.as_mut().unwrap().start()?;
         self.sink.as_mut().unwrap().start()?;
         self.resize_bitmaps();
diff --git a/scheduler/src/source.rs b/scheduler/src/source.rs
index 549ac57..fac4a0b 100644
--- a/scheduler/src/source.rs
+++ b/scheduler/src/source.rs
@@ -465,7 +465,7 @@ impl Source {
                 // This is an own mount in our mount namespace, thus we need
                 // to explicitly mount it.
                 jail.bind_rw(&workdir);
-                jail.no_random_devices();
+                // jail.no_random_devices();
                 Some(jail.build()?)
             } else {
                 None
@@ -740,8 +740,24 @@ impl Source {
                     assert_eq!(ret, 0);
 
                     // Disable ASLR since we rely on all instances having the same memory layout.
-                    let ret = libc::personality(libc::ADDR_NO_RANDOMIZE as u64);
-                    assert_eq!(ret, 0);
+                    let _ = libc::personality(libc::ADDR_NO_RANDOMIZE as u64);
+                    let check_personality = libc::personality(0xffffffff);
+                    if check_personality & libc::ADDR_NO_RANDOMIZE == 0 {
+                        let err = std::io::Error::last_os_error();
+                        let errno = err.raw_os_error().unwrap_or(0);
+                        match errno {
+                            libc::EINVAL => {
+                                log::error!("Invalid argument");
+                            }
+                            libc::EPERM => {
+                                log::error!("Operation not permitted");
+                            }
+                            _ => {
+                                log::error!("Unknown error: {}", errno);
+                            }
+                        }
+                        panic!("Failed to disable ASLR");
+                    }
 
                     if let Some(ref mut jail) = self.jail {
                         // ! Make sure that the code in `enter()` is async-signal-safe since we
